# План реализации программы ChatList

## Этап 1: Подготовка проекта и окружения

### 1.1 Обновление зависимостей
- [ ] Добавить в `requirements.txt`:
  - `requests` или `httpx` для HTTP-запросов
  - `python-dotenv` для работы с `.env` файлом
  - Обновить версии существующих зависимостей

### 1.2 Структура проекта
- [ ] Создать структуру папок:
  - `src/` - основной код приложения
  - `src/db.py` - модуль работы с БД
  - `src/models.py` - модуль работы с моделями
  - `src/network.py` - модуль сетевых запросов
  - `src/ui/` - модули интерфейса (если потребуется)
- [ ] Создать файл `.env.example` с примером переменных окружения
- [ ] Обновить `.gitignore` для исключения `.env` и других служебных файлов

## Этап 2: База данных (db.py)

### 2.1 Создание схемы БД
- [ ] Реализовать функцию инициализации БД `init_database()`
- [ ] Создать таблицу `prompts`:
  - `id` INTEGER PRIMARY KEY AUTOINCREMENT
  - `date` TEXT (ISO формат)
  - `prompt` TEXT
  - `tags` TEXT (JSON или разделённые запятыми)
- [ ] Создать таблицу `models`:
  - `id` INTEGER PRIMARY KEY AUTOINCREMENT
  - `name` TEXT UNIQUE
  - `api_url` TEXT
  - `api_key_env` TEXT (имя переменной окружения)
  - `is_active` INTEGER (0/1)
  - `model_type` TEXT (openai, deepseek, groq и т.д.)
- [ ] Создать таблицу `results`:
  - `id` INTEGER PRIMARY KEY AUTOINCREMENT
  - `prompt_id` INTEGER (FK к prompts)
  - `model_id` INTEGER (FK к models)
  - `response_text` TEXT
  - `created_at` TEXT (ISO формат)
- [ ] Создать таблицу `settings`:
  - `key` TEXT PRIMARY KEY
  - `value` TEXT

### 2.2 CRUD операции для таблиц
- [ ] Реализовать функции для работы с `prompts`:
  - `create_prompt()`, `get_prompts()`, `get_prompt_by_id()`, `update_prompt()`, `delete_prompt()`
- [ ] Реализовать функции для работы с `models`:
  - `create_model()`, `get_models()`, `get_active_models()`, `update_model()`, `toggle_model_active()`
- [ ] Реализовать функции для работы с `results`:
  - `save_results()`, `get_results()`, `get_results_by_prompt()`
- [ ] Реализовать функции для работы с `settings`:
  - `get_setting()`, `set_setting()`

### 2.3 Поиск и сортировка
- [ ] Реализовать функцию поиска по промтам (по тексту и тегам)
- [ ] Реализовать функцию поиска по результатам
- [ ] Добавить поддержку сортировки для всех таблиц

## Этап 3: Модуль работы с моделями (models.py)

### 3.1 Класс Model
- [ ] Создать класс `Model` с полями:
  - `id`, `name`, `api_url`, `api_key_env`, `is_active`, `model_type`
- [ ] Реализовать метод `get_api_key()` для получения ключа из `.env`
- [ ] Реализовать метод `validate()` для проверки корректности данных

### 3.2 Управление моделями
- [ ] Реализовать функцию `load_models()` для загрузки из БД
- [ ] Реализовать функцию `get_active_models()` для получения активных моделей
- [ ] Реализовать функцию `add_default_models()` для добавления моделей по умолчанию

## Этап 4: Сетевые запросы (network.py)

### 4.1 Базовый класс для API
- [ ] Создать базовый класс `BaseAPIProvider` с общими методами
- [ ] Реализовать обработку ошибок и таймаутов

### 4.2 Провайдеры для разных API
- [ ] Реализовать класс `OpenAIProvider` для OpenAI API
- [ ] Реализовать класс `DeepSeekProvider` для DeepSeek API
- [ ] Реализовать класс `GroqProvider` для Groq API
- [ ] Реализовать фабрику провайдеров `get_provider(model_type)`

### 4.3 Отправка запросов
- [ ] Реализовать функцию `send_prompt_to_model(prompt, model)` для отправки запроса
- [ ] Реализовать асинхронную отправку запросов к нескольким моделям
- [ ] Добавить обработку ошибок и логирование

### 4.4 Логирование
- [ ] Реализовать логирование всех запросов и ответов
- [ ] Сохранять логи в файл или БД (опционально)

## Этап 5: Графический интерфейс (main.py)

### 5.1 Основная структура окна
- [ ] Создать класс `MainWindow(QMainWindow)`
- [ ] Разделить окно на области:
  - Панель ввода промта (сверху)
  - Таблица результатов (по центру)
  - Панель управления (внизу)

### 5.2 Панель ввода промта
- [ ] Создать текстовое поле для ввода нового промта
- [ ] Создать выпадающий список для выбора сохранённых промтов
- [ ] Добавить кнопку "Отправить"
- [ ] Добавить кнопку "Сохранить промт" с полем для тегов

### 5.3 Таблица результатов
- [ ] Создать таблицу `QTableWidget` с колонками:
  - Чекбокс (selected)
  - Название модели
  - Текст ответа
- [ ] Реализовать отображение временных результатов (в памяти)
- [ ] Добавить возможность прокрутки длинных ответов
- [ ] Реализовать авто-подбор ширины колонок

### 5.4 Панель управления
- [ ] Добавить кнопку "Сохранить выбранные"
- [ ] Добавить кнопку "Очистить результаты"
- [ ] Добавить индикатор загрузки во время отправки запросов

### 5.5 Обработка событий
- [ ] Реализовать обработчик отправки промта
- [ ] Реализовать обновление таблицы результатов после получения ответов
- [ ] Реализовать сохранение выбранных результатов
- [ ] Реализовать очистку временной таблицы при новом запросе

## Этап 6: Управление моделями (UI)

### 6.1 Окно настройки моделей
- [ ] Создать диалоговое окно для управления моделями
- [ ] Реализовать список моделей с чекбоксами (is_active)
- [ ] Добавить возможность добавления/редактирования/удаления моделей
- [ ] Добавить валидацию полей

### 6.2 Интеграция с главным окном
- [ ] Добавить пункт меню "Настройки" -> "Управление моделями"
- [ ] Обновлять список активных моделей после изменений

## Этап 7: Просмотр истории

### 7.1 Окно истории промтов
- [ ] Создать окно для просмотра сохранённых промтов
- [ ] Реализовать поиск по тексту и тегам
- [ ] Реализовать сортировку по дате
- [ ] Добавить возможность выбора промта для повторного использования

### 7.2 Окно истории результатов
- [ ] Создать окно для просмотра сохранённых результатов
- [ ] Реализовать фильтрацию по промту и модели
- [ ] Реализовать поиск и сортировку
- [ ] Добавить возможность экспорта

## Этап 8: Дополнительные функции

### 8.1 Экспорт результатов
- [ ] Реализовать экспорт в Markdown формат
- [ ] Реализовать экспорт в JSON формат
- [ ] Добавить диалог выбора файла для сохранения

### 8.2 Улучшение интерфейса
- [ ] Добавить иконки для кнопок
- [ ] Улучшить визуальное оформление
- [ ] Добавить горячие клавиши
- [ ] Реализовать тёмную тему (опционально)

### 8.3 Обработка ошибок
- [ ] Добавить обработку ошибок сети
- [ ] Добавить обработку ошибок API
- [ ] Показывать понятные сообщения об ошибках пользователю

## Этап 9: AI-ассистент для улучшения промтов

### 9.1 Модуль улучшения промтов (src/prompt_enhancer.py)
- [ ] Создать модуль `prompt_enhancer.py` для логики улучшения промтов
- [ ] Реализовать функцию `enhance_prompt(prompt, model)` для отправки запроса на улучшение
- [ ] Реализовать функцию `generate_alternatives(prompt, model)` для генерации альтернативных вариантов
- [ ] Реализовать функцию `adapt_prompt_for_type(prompt, model_type, model)` для адаптации под разные типы моделей
- [ ] Создать промпты-шаблоны для разных типов улучшения:
  - Общее улучшение промта
  - Переформулировка (2-3 варианта)
  - Адаптация для кода
  - Адаптация для анализа
  - Адаптация для креативных задач

### 9.2 Диалог улучшения промтов (src/ui/prompt_enhancer_dialog.py)
- [ ] Создать класс `PromptEnhancerDialog(QDialog)` для отображения результатов улучшения
- [ ] Реализовать отображение исходного промта
- [ ] Реализовать отображение улучшенной версии промта
- [ ] Реализовать отображение 2-3 альтернативных вариантов переформулировки
- [ ] Добавить вкладки или секции для разных типов адаптации (код, анализ, креатив)
- [ ] Реализовать кнопки "Подставить в поле ввода" для каждого варианта
- [ ] Добавить индикатор загрузки во время обработки запроса
- [ ] Реализовать выбор модели для улучшения (выпадающий список активных моделей)

### 9.3 Интеграция в главное окно (main.py)
- [ ] Добавить кнопку "Улучшить промт" рядом с полем ввода промта
- [ ] Реализовать обработчик `on_enhance_prompt_clicked()`:
  - Проверка наличия текста в поле ввода
  - Открытие диалога улучшения промтов
  - Передача текущего текста промта в диалог
- [ ] Реализовать механизм подстановки выбранного варианта в поле ввода:
  - Обработка сигнала из диалога с выбранным вариантом
  - Замена текста в `prompt_input`
- [ ] Добавить горячую клавишу для быстрого доступа (например, `Ctrl+I`)

### 9.4 Обработка ответов от AI
- [ ] Реализовать парсинг ответа от модели для извлечения:
  - Улучшенной версии промта
  - Альтернативных вариантов (2-3)
  - Адаптированных версий для разных типов задач
- [ ] Добавить обработку ошибок при запросе улучшения
- [ ] Реализовать валидацию полученных результатов
- [ ] Добавить возможность повторной отправки запроса при ошибке

### 9.5 Оптимизация и кэширование
- [ ] Реализовать кэширование результатов улучшения (опционально)
- [ ] Добавить возможность сохранения улучшенных промтов в историю
- [ ] Оптимизировать промпты-шаблоны для уменьшения токенов
- [ ] Добавить настройку количества альтернативных вариантов

### 9.6 Тестирование функции улучшения
- [ ] Протестировать улучшение различных типов промтов
- [ ] Протестировать работу с разными моделями
- [ ] Протестировать обработку ошибок и таймаутов
- [ ] Протестировать подстановку вариантов в поле ввода

## Этап 10: Тестирование и оптимизация

### 9.1 Тестирование
- [ ] Протестировать работу с БД
- [ ] Протестировать отправку запросов к разным API
- [ ] Протестировать интерфейс пользователя
- [ ] Протестировать обработку ошибок

### 9.2 Оптимизация
- [ ] Оптимизировать запросы к БД
- [ ] Оптимизировать работу с большими текстами в таблице
- [ ] Добавить кэширование при необходимости

## Этап 11: Документация и финализация

### 10.1 Документация
- [ ] Обновить README.md с инструкциями по использованию
- [ ] Добавить комментарии в код
- [ ] Создать пример файла `.env`

### 10.2 Сборка
- [ ] Обновить `build.ps1` для включения всех модулей
- [ ] Протестировать сборку исполняемого файла
- [ ] Проверить работу собранного приложения
